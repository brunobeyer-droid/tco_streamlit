import streamlit as st
import uuid
from typing import Optional

# If your DB utils live under utils/, change import accordingly.
from snowflake_db import ensure_tables, fetch_df, upsert_program, execute

try:
    from utils.sidebar import render_global_actions
except Exception:
    def render_global_actions(): pass

st.set_page_config(page_title="Programs", page_icon="üóÇÔ∏è", layout="wide")
render_global_actions()
ensure_tables()

st.title("üóÇÔ∏è Programs")

def _programs_df():
    return fetch_df("""
        SELECT PROGRAMID, PROGRAMNAME, PROGRAMOWNER, PROGRAMFTE
        FROM PROGRAMS
        ORDER BY PROGRAMNAME
    """)

# ---------------------------
# Create / Edit flow (no Program ID field)
# ---------------------------
st.subheader("Create or Edit Program")

progs = _programs_df()
mode = st.radio("Mode", ["Create New", "Edit Existing"], horizontal=True)

# Prefill values if editing
edit_program_id = None
prefill_name = ""
prefill_owner = ""
prefill_fte = 0.0

if mode == "Edit Existing":
    if progs is None or progs.empty:
        st.warning("No programs yet. Switch to 'Create New'.")
    else:
        progs["LABEL"] = progs["PROGRAMNAME"].astype(str) + " ¬∑ " + progs["PROGRAMID"].astype(str)
        choice = st.selectbox("Select a program to edit", progs["LABEL"].tolist(), key="prog_edit_select")
        # pull row
        row = progs[progs["LABEL"] == choice].iloc[0]
        edit_program_id = row["PROGRAMID"]
        prefill_name = str(row.get("PROGRAMNAME") or "")
        prefill_owner = str(row.get("PROGRAMOWNER") or "")
        try:
            prefill_fte = float(row.get("PROGRAMFTE") or 0.0)
        except Exception:
            prefill_fte = 0.0

# Input fields
col1, col2, col3 = st.columns(3)
with col1:
    program_name = st.text_input("Program Name (required)", value=prefill_name, key="prog_name")
with col2:
    program_manager = st.text_input("Program Manager (required)", value=prefill_owner, key="prog_mgr")
with col3:
    program_fte = st.number_input("Program FTE", min_value=0.0, step=0.1, format="%.1f",
                                  value=prefill_fte, key="prog_fte")

if st.button("üíæ Save Program", key="prog_save_btn"):
    if not program_name.strip():
        st.error("Program Name is required.")
    elif not program_manager.strip():
        st.error("Program Manager is required.")
    else:
        # If editing, keep the same PROGRAMID. If creating, generate a new one.
        program_id = edit_program_id or str(uuid.uuid4())
        # Store Program Manager into PROGRAMOWNER column (no schema change needed).
        upsert_program(
            program_id=program_id,
            name=program_name.strip(),
            owner=program_manager.strip(),
            fte=float(program_fte) if program_fte is not None else None
        )
        st.success(f"Program saved (PROGRAMID: {program_id}).")
        st.cache_data.clear()

st.markdown("---")

# ---------------------------
# Programs table
# ---------------------------
st.subheader("Programs")
progs = _programs_df()
if progs is not None and not progs.empty:
    st.dataframe(
        progs.rename(columns={"PROGRAMOWNER": "PROGRAMMANAGER"})[["PROGRAMID", "PROGRAMNAME", "PROGRAMMANAGER", "PROGRAMFTE"]],
        use_container_width=True
    )
else:
    st.info("No programs yet.")

# ---------------------------
# Danger zone: delete
# ---------------------------
with st.expander("Danger zone: Delete a Program"):
    if progs is None or progs.empty:
        st.info("No programs to delete.")
    else:
        # pick via dropdown instead of raw ID to avoid mistakes
        progs["LABEL"] = progs["PROGRAMNAME"].astype(str) + " ¬∑ " + progs["PROGRAMID"].astype(str)
        del_choice = st.selectbox("Select a program to delete", progs["LABEL"].tolist(), key="prog_delete_select")
        confirm = st.text_input("Type DELETE to confirm", key="prog_delete_confirm")
        if st.button("üóëÔ∏è Delete Program", key="prog_delete_btn"):
            if confirm.strip().upper() != "DELETE":
                st.error("Type DELETE to confirm.")
            else:
                pid = progs[progs["LABEL"] == del_choice]["PROGRAMID"].iloc[0]
                try:
                    execute("DELETE FROM PROGRAMS WHERE PROGRAMID = %s", (pid,))
                    st.success("Program deleted.")
                    st.cache_data.clear()
                except Exception as e:
                    st.error(f"Delete failed: {e}")
