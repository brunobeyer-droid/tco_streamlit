# pages/invoice_tracking.py
import uuid
from datetime import date
from typing import Optional, List, Any, Tuple

import pandas as pd
import streamlit as st

from snowflake_db import (
    list_programs,
    list_teams,
    list_groups_for_team,
    list_application_groups,
    list_applications,
    upsert_invoice,
    fetch_df,
    execute,
    delete_invoice,
    list_vendors,  # for Vendor filter
)

st.set_page_config(page_title="Invoice Tracking", page_icon="üßæ", layout="wide")

# Init counters used to reset uploaders
if "create_upload_key" not in st.session_state:
    st.session_state["create_upload_key"] = 0

# --------------------------------------------------------------------------------------
# Utilities
# --------------------------------------------------------------------------------------
def _safe_years(start: int = 2020, end: int = 2036) -> List[int]:
    return list(range(start, end + 1))

def _ensure_str(x) -> Optional[str]:
    s = str(x).strip() if x is not None else ""
    return s if s else None

def _to_int_opt(x) -> Optional[int]:
    """Return int(x) or None for '', None, NaN, or non-numeric."""
    try:
        if x is None:
            return None
        try:
            if pd.isna(x):
                return None
        except Exception:
            pass
        s = str(x).strip()
        if not s:
            return None
        return int(float(s))  # tolerate '2027.0'
    except Exception:
        return None

# --------------------------------------------------------------------------------------
# Caching wrappers (speed!)
# --------------------------------------------------------------------------------------
@st.cache_data(ttl=300, show_spinner=False)
def cached_list_programs():
    return list_programs()

@st.cache_data(ttl=300, show_spinner=False)
def cached_list_teams():
    return list_teams()

@st.cache_data(ttl=300, show_spinner=False)
def cached_list_groups_for_team(team_id: str):
    return list_groups_for_team(team_id)

@st.cache_data(ttl=300, show_spinner=False)
def cached_list_application_groups():
    return list_application_groups()

@st.cache_data(ttl=300, show_spinner=False)
def cached_list_applications(team_id: Optional[str] = None, group_id: Optional[str] = None):
    return list_applications(team_id=team_id, group_id=group_id)

@st.cache_data(ttl=300, show_spinner=False)
def cached_list_vendors():
    return list_vendors()

@st.cache_data(ttl=60, show_spinner=False)
def cached_fetch_invoice_by_id(invoice_id: str) -> pd.DataFrame:
    return fetch_df("""
        SELECT
            INVOICEID,
            APPLICATIONID,
            TEAMID,
            GROUPID,
            FISCAL_YEAR,
            RENEWALDATE,
            AMOUNT,
            STATUS,
            AMOUNT_NEXT_YEAR,
            CONTRACT_ACTIVE,
            COMPANY_CODE,
            COST_CENTER,
            SERIAL_NUMBER,
            WORK_ORDER,
            AGREEMENT_NUMBER,
            CONTRACT_DUE,
            SERVICE_TYPE,
            NOTES,
            COALESCE(INVOICE_TYPE,'Recurring Invoice') AS INVOICE_TYPE
        FROM INVOICES
        WHERE INVOICEID = %s
        """, (invoice_id,)
    )

# --------------------------------------------------------------------------------------
# Notes & Attachments helpers
# --------------------------------------------------------------------------------------
def _note_append(invoice_id: str, note_text: str, created_by: Optional[str] = None):
    if not note_text.strip():
        return
    note_id = str(uuid.uuid4())
    db = st.secrets["snowflake"].get("database", "TCODB")
    sc = st.secrets["snowflake"].get("schema", "PUBLIC")
    execute(f"""
        INSERT INTO {db}.{sc}.INVOICE_NOTES
        (NOTE_ID, INVOICEID, NOTE_TEXT, CREATED_BY)
        VALUES (%s, %s, %s, %s)
    """, (note_id, invoice_id, note_text, created_by))

def _list_notes(invoice_id: str) -> pd.DataFrame:
    db = st.secrets["snowflake"].get("database", "TCODB")
    sc = st.secrets["snowflake"].get("schema", "PUBLIC")
    return fetch_df(f"""
        SELECT NOTE_ID, NOTE_TEXT, CREATED_AT, CREATED_BY
        FROM {db}.{sc}.INVOICE_NOTES
        WHERE INVOICEID = %s
        ORDER BY CREATED_AT DESC
    """, (invoice_id,))

def _save_attachment(invoice_id: str, filename: str, mimetype: str, content: bytes):
    attach_id = str(uuid.uuid4())
    db = st.secrets["snowflake"].get("database", "TCODB")
    sc = st.secrets["snowflake"].get("schema", "PUBLIC")
    execute(f"""
        INSERT INTO {db}.{sc}.INVOICE_ATTACHMENTS
        (ATTACHMENT_ID, INVOICEID, FILENAME, MIMETYPE, CONTENT)
        VALUES (%s, %s, %s, %s, %s)
    """, (attach_id, invoice_id, filename, mimetype, content))

def _list_attachments(invoice_id: str) -> pd.DataFrame:
    db = st.secrets["snowflake"].get("database", "TCODB")
    sc = st.secrets["snowflake"].get("schema", "PUBLIC")
    return fetch_df(f"""
        SELECT ATTACHMENT_ID, FILENAME, MIMETYPE, UPLOADED_AT
        FROM {db}.{sc}.INVOICE_ATTACHMENTS
        WHERE INVOICEID = %s
        ORDER BY UPLOADED_AT DESC
    """, (invoice_id,))

# --------------------------------------------------------------------------------------
# Reset helpers
# --------------------------------------------------------------------------------------
def _reset_create_form_state():
    keys = [
        "create_year_sel",
        "create_invoice_type",
        "create_prog_sel",
        "create_team_sel",
        "create_group_sel",
        "create_app_sel",
        "create_contract_active",
        "create_renewal_dt",
        "create_amount",
        "create_status",
        "create_amount_ny",
        "create_company_code",
        "create_cost_center",
        "create_serial",
        "create_workorder",
        "create_agreement",
        "create_contract_due",
        "create_service_type",
        "create_notes_inline",
    ]
    for k in keys:
        st.session_state.pop(k, None)
    st.session_state["create_upload_key"] = st.session_state.get("create_upload_key", 0) + 1

def _clear_inline_edit_state():
    for k in [
        "search_edit_invoice_id",
        "search_edit_ctx",
        "search_show_delete_confirm",
        "search_confirm_delete_checkbox",
        # field widgets
        "search_edit_contract_active",
        "search_edit_renewal_dt",
        "search_edit_amount",
        "search_edit_status",
        "search_edit_amount_ny",
        "search_edit_company_code",
        "search_edit_cost_center",
        "search_edit_serial",
        "search_edit_workorder",
        "search_edit_agreement",
        "search_edit_contract_due",
        "search_edit_service_type",
        "search_edit_notes_inline",
    ]:
        st.session_state.pop(k, None)

# --------------------------------------------------------------------------------------
# Cascading selector
# --------------------------------------------------------------------------------------
def _select_team_group_app(prefix: str) -> Tuple[Optional[str], Optional[str], Optional[str], Optional[str], Optional[str]]:
    programs_df = cached_list_programs()
    prog_names = programs_df["PROGRAMNAME"].tolist() if not programs_df.empty else []
    sel_prog_name = st.selectbox("Program", options=["Select Program"] + prog_names, index=0, key=f"{prefix}_prog_sel")
    sel_program_id = None
    if sel_prog_name != "Select Program" and not programs_df.empty:
        sel_program_id = programs_df.loc[programs_df["PROGRAMNAME"] == sel_prog_name, "PROGRAMID"].iloc[0]

    teams_df = cached_list_teams()
    if sel_program_id:
        teams_df = teams_df.loc[teams_df["PROGRAMID"] == sel_program_id]
    if teams_df.empty:
        st.warning("No Teams found for this selection.")
        return sel_program_id, None, None, None, None

    team_names = teams_df["TEAMNAME"].tolist()
    sel_team_name = st.selectbox("Team", options=["Select Team"] + team_names, index=0, key=f"{prefix}_team_sel")
    if sel_team_name == "Select Team":
        return sel_program_id, None, None, None, None
    sel_team_row = teams_df.loc[teams_df["TEAMNAME"] == sel_team_name].iloc[0]
    sel_team_id = sel_team_row["TEAMID"]

    groups_df = cached_list_groups_for_team(sel_team_id)
    if groups_df.empty:
        st.info("This team has no Application Groups yet.")
        return sel_program_id, sel_team_id, sel_team_name, None, None
    group_names = groups_df["GROUPNAME"].tolist()
    sel_group_name = st.selectbox("Application Group", options=["Select Group"] + group_names, index=0, key=f"{prefix}_group_sel")
    if sel_group_name == "Select Group":
        return sel_program_id, sel_team_id, sel_team_name, None, None
    sel_group_row = groups_df.loc[groups_df["GROUPNAME"] == sel_group_name].iloc[0]
    sel_group_id = sel_group_row["GROUPID"]

    apps_df = cached_list_applications(group_id=sel_group_id)
    if apps_df.empty:
        st.info("No Application Instances in this group. Create one in the Applications page.")
        return sel_program_id, sel_team_id, sel_team_name, sel_group_id, None

    apps_df = apps_df.copy()
    apps_df["LABEL"] = apps_df.apply(
        lambda r: f"{r['APPLICATIONNAME']}" + (f" ‚Äî {r['SITE']}" if r.get("SITE") else ""),
        axis=1
    )
    app_labels = apps_df["LABEL"].tolist()
    sel_app_label = st.selectbox("Application Instance", options=["Select Application"] + app_labels, index=0, key=f"{prefix}_app_sel")
    if sel_app_label == "Select Application":
        return sel_program_id, sel_team_id, sel_team_name, sel_group_id, None
    sel_app_row = apps_df.iloc[app_labels.index(sel_app_label)]
    sel_app_id = sel_app_row["APPLICATIONID"]

    return sel_program_id, sel_team_id, sel_team_name, sel_group_id, sel_app_id

# --------------------------------------------------------------------------------------
# Field renderer (aligned rows; Contract Active occupies left column only)
# Also swaps Cost Center and Amount Next Year for Recurring invoices (as requested)
# --------------------------------------------------------------------------------------
def _edit_create_fields(prefix: str, loaded_invoice: Optional[pd.Series],
                        selected_team_name: Optional[str],
                        invoice_type: Optional[str] = "Recurring Invoice") -> dict:
    """
    Return dict of field values. For Ad Hoc: show only Amount, Status, Renewal Date,
    Work Order, Cost Center, Company Code, Notes.
    """
    show_all = (invoice_type != "Ad Hoc Invoice")
    def _d(col):
        return loaded_invoice.get(col) if loaded_invoice is not None else None

    notes_inline: Optional[str] = _ensure_str(_d("NOTES")) if loaded_invoice is not None else ""

    # Row 0: Contract Active (left only)
    r0c1, r0c2 = st.columns(2, gap="small")
    if show_all:
        default_contract_active = bool(_d("CONTRACT_ACTIVE")) if loaded_invoice is not None else True
        with r0c1:
            contract_active = st.checkbox("Contract Active", value=default_contract_active, key=f"{prefix}_contract_active")
    else:
        contract_active = True
    with r0c2:
        st.empty()

    # Row 1: Renewal Date | Company Code
    r1c1, r1c2 = st.columns(2, gap="small")
    with r1c1:
        if loaded_invoice is not None and pd.notna(_d("RENEWALDATE")):
            default_date = pd.to_datetime(_d("RENEWALDATE")).date()
        else:
            default_date = date.today()
        renewal_date = st.date_input("Renewal Date", value=default_date, key=f"{prefix}_renewal_dt")
    with r1c2:
        company_code = st.text_input("Company Code", value=_ensure_str(_d("COMPANY_CODE")) if loaded_invoice is not None else "", key=f"{prefix}_company_code")

    # Row 2: Amount | Amount Next Year (Recurring)  OR  Amount | Cost Center (Ad Hoc)
    r2c1, r2c2 = st.columns(2, gap="small")
    with r2c1:
        default_amount = float(_d("AMOUNT")) if (loaded_invoice is not None and _d("AMOUNT") is not None) else 0.0
        amount = st.number_input("Amount (KUSD)", min_value=0.0, step=0.1, value=default_amount, key=f"{prefix}_amount")
    with r2c2:
        if show_all:
            default_amount_ny = float(_d("AMOUNT_NEXT_YEAR")) if (loaded_invoice is not None and _d("AMOUNT_NEXT_YEAR") is not None) else 0.0
            amount_next_year = st.number_input("Amount Next Year (KUSD)", min_value=0.0, step=0.1, value=default_amount_ny, key=f"{prefix}_amount_ny")
            cost_center_r2 = None
        else:
            amount_next_year = 0.0
            cost_center_r2 = st.text_input("Cost Center", value=_ensure_str(_d("COST_CENTER")) if loaded_invoice is not None else "", key=f"{prefix}_cost_center")

    # Row 3: Status | Cost Center (Recurring)  OR  Status | Notes (Ad Hoc)
    r3c1, r3c2 = st.columns(2, gap="small")
    with r3c1:
        default_status = _d("STATUS") if loaded_invoice is not None else "Planned"
        status = st.selectbox(
            "Status",
            options=["Planned", "Completed"],
            index=["Planned", "Completed"].index(default_status if default_status in ["Planned", "Completed"] else "Planned"),
            key=f"{prefix}_status"
        )
    with r3c2:
        if show_all:
            # Cost Center lives here for Recurring (swapped with Amount Next Year)
            cost_center = st.text_input("Cost Center", value=_ensure_str(_d("COST_CENTER")) if loaded_invoice is not None else "", key=f"{prefix}_cost_center_rec")
        else:
            cost_center = cost_center_r2  # came from Row 2 (Ad Hoc)
            notes_inline = st.text_area("Notes (inline, short)", value=notes_inline or "", key=f"{prefix}_notes_inline", height=84)

    # Row 4: Work Order | Contract Due (Recurring only)
    r4c1, r4c2 = st.columns(2, gap="small")
    with r4c1:
        work_order = st.text_input("Work Order", value=_ensure_str(_d("WORK_ORDER")) if loaded_invoice is not None else "", key=f"{prefix}_workorder")
    with r4c2:
        if show_all:
            contract_due_opts = ["undefined"] + [str(y) for y in _safe_years(2026, 2034)]
            raw_due = _d("CONTRACT_DUE")
            due_val = _to_int_opt(raw_due)
            default_due = str(due_val) if due_val is not None else "undefined"
            due_index = contract_due_opts.index(default_due) if default_due in contract_due_opts else 0
            contract_due_sel = st.selectbox("Contract Due", options=contract_due_opts, index=due_index, key=f"{prefix}_contract_due")
            contract_due = None if contract_due_sel == "undefined" else int(contract_due_sel)
        else:
            contract_due = None
            st.empty()

    # Row 5: Serial Number | Service Type (Recurring only)
    if show_all:
        r5c1, r5c2 = st.columns(2, gap="small")
        with r5c1:
            serial_number = st.text_input("Serial Number", value=_ensure_str(_d("SERIAL_NUMBER")) if loaded_invoice is not None else "", key=f"{prefix}_serial")
        with r5c2:
            svc_types = ["OnPrem", "SaaS", "IaaS", "Other"]
            default_svc = _d("SERVICE_TYPE") if loaded_invoice is not None else "SaaS"
            service_type = st.selectbox(
                "Service Type",
                options=svc_types,
                index=svc_types.index(default_svc) if default_svc in svc_types else svc_types.index("SaaS"),
                key=f"{prefix}_service_type"
            )
    else:
        serial_number = None
        service_type = None

    # Row 6: Agreement Number | Notes (Recurring only; Ad Hoc notes already in Row 3)
    if show_all:
        r6c1, r6c2 = st.columns(2, gap="small")
        with r6c1:
            agreement_number = st.text_input("Agreement Number", value=_ensure_str(_d("AGREEMENT_NUMBER")) if loaded_invoice is not None else "", key=f"{prefix}_agreement")
        with r6c2:
            notes_inline = st.text_area("Notes (inline, short)", value=notes_inline or "", key=f"{prefix}_notes_inline", height=84)
    else:
        agreement_number = None

    # Attachments input
    st.markdown("**Attachments (optional)**")
    upload_key = f"{prefix}_attachments"
    if prefix.startswith("create"):
        upload_key = f"{upload_key}_{st.session_state.get('create_upload_key', 0)}"
    uploaded_files = st.file_uploader("Upload files", accept_multiple_files=True, key=upload_key)

    return {
        "renewal_date": renewal_date,
        "amount": amount,
        "status": status,
        "amount_next_year": amount_next_year,
        "contract_active": contract_active if show_all else True,
        "company_code": company_code,
        "cost_center": cost_center,
        "serial_number": serial_number,
        "work_order": work_order,
        "agreement_number": agreement_number,
        "contract_due": contract_due if show_all else None,
        "service_type": service_type,
        "notes_inline": notes_inline,
        "uploaded_files": uploaded_files,
        "product_owner_implicit": selected_team_name or None,
    }

# --------------------------------------------------------------------------------------
# Save helper
# --------------------------------------------------------------------------------------
def _save_invoice_and_attachments(invoice_id: str, values: dict):
    upsert_invoice(
        invoice_id=invoice_id,
        application_id=values["application_id"],
        team_id=values["team_id"],
        renewal_date=values["renewal_date"].isoformat() if hasattr(values["renewal_date"], "isoformat") else values["renewal_date"],
        amount=float(values["amount"]),
        status=values["status"],
        fiscal_year=int(values["fiscal_year"]),
        product_owner=_ensure_str(values["product_owner_implicit"]),
        amount_next_year=float(values["amount_next_year"]) if values["amount_next_year"] is not None else None,
        contract_active=bool(values["contract_active"]) if values["contract_active"] is not None else None,
        company_code=_ensure_str(values["company_code"]),
        cost_center=_ensure_str(values["cost_center"]),
        serial_number=_ensure_str(values["serial_number"]),
        work_order=_ensure_str(values["work_order"]),
        agreement_number=_ensure_str(values["agreement_number"]),
        contract_due=values["contract_due"] if values["contract_due"] is not None else None,
        service_type=_ensure_str(values["service_type"]),
        notes=_ensure_str(values["notes_inline"]),
        group_id=_ensure_str(values["group_id"]),
        programid_at_booking=_ensure_str(values.get("programid_at_booking")),
        vendorid_at_booking=_ensure_str(values.get("vendorid_at_booking")),
        groupid_at_booking=_ensure_str(values.get("groupid_at_booking")),
        rollover_batch_id=None,
        rolled_over_from_year=None,
        invoice_type=values.get("invoice_type"),
    )

    uploads = values.get("uploaded_files")
    if uploads:
        for f in uploads:
            try:
                _save_attachment(invoice_id, f.name, f.type or "application/octet-stream", f.read())
            except Exception as e:
                st.warning(f"Attachment '{f.name}' could not be saved: {e}")

# --------------------------------------------------------------------------------------
# Search helper (enriched) with extra filters + ordering
# --------------------------------------------------------------------------------------
def _search_invoices_enriched(
    fiscal_year: Optional[int],
    program_id: Optional[str],
    team_id: Optional[str],
    group_id: Optional[str],
    application_id: Optional[str],
    status_filter: Optional[str] = None,
    invoice_type_filter: Optional[str] = None,
    agreement_like: Optional[str] = None,
    vendor_id: Optional[str] = None,
    order_status: Optional[str] = None,   # "Planned first" | "Completed first" | None
    order_date: Optional[str] = None,     # "Newest first" | "Oldest first" | None
) -> pd.DataFrame:
    where = []
    params: List[Any] = []
    if fiscal_year:
        where.append("i.FISCAL_YEAR = %s")
        params.append(int(fiscal_year))
    if team_id:
        where.append("i.TEAMID = %s")
        params.append(team_id)
    if application_id:
        where.append("i.APPLICATIONID = %s")
        params.append(application_id)
    if group_id:
        where.append("a.GROUPID = %s")
        params.append(group_id)
    if program_id:
        where.append("t.PROGRAMID = %s")
        params.append(program_id)
    if status_filter and status_filter in ("Planned", "Completed"):
        where.append("i.STATUS = %s")
        params.append(status_filter)
    if invoice_type_filter and invoice_type_filter in ("Recurring Invoice", "Ad Hoc Invoice"):
        where.append("COALESCE(i.INVOICE_TYPE,'Recurring Invoice') = %s")
        params.append(invoice_type_filter)
    if agreement_like and agreement_like.strip():
        where.append("i.AGREEMENT_NUMBER ILIKE %s")
        params.append(f"%{agreement_like.strip()}%")
    if vendor_id:
        where.append("a.VENDORID = %s")
        params.append(vendor_id)

    where_sql = ("WHERE " + " AND ".join(where)) if where else ""

    # ORDER BY
    order_parts = []
    if order_status == "Planned first":
        order_parts.append("CASE WHEN i.STATUS='Planned' THEN 0 ELSE 1 END ASC")
    elif order_status == "Completed first":
        order_parts.append("CASE WHEN i.STATUS='Completed' THEN 0 ELSE 1 END ASC")

    if order_date == "Newest first":
        order_parts.append("i.RENEWALDATE DESC NULLS LAST")
    elif order_date == "Oldest first":
        order_parts.append("i.RENEWALDATE ASC NULLS LAST")

    # sensible tiebreakers
    order_parts.extend(["t.TEAMNAME", "g.GROUPNAME", "a.APPLICATIONNAME"])
    order_sql = "ORDER BY " + ", ".join(order_parts)

    sql = f"""
        SELECT
            i.INVOICEID,
            i.FISCAL_YEAR,
            i.RENEWALDATE,
            i.AMOUNT,
            i.STATUS,
            COALESCE(i.INVOICE_TYPE,'Recurring Invoice') AS INVOICE_TYPE,
            i.AGREEMENT_NUMBER,
            t.TEAMID, t.TEAMNAME,
            g.GROUPID, g.GROUPNAME,
            a.APPLICATIONID, a.APPLICATIONNAME, a.SITE, a.VENDORID
        FROM INVOICES i
        LEFT JOIN TEAMS t              ON t.TEAMID  = i.TEAMID
        LEFT JOIN APPLICATIONS a       ON a.APPLICATIONID = i.APPLICATIONID
        LEFT JOIN APPLICATION_GROUPS g ON g.GROUPID = a.GROUPID
        {where_sql}
        {order_sql}
    """
    df = fetch_df(sql, tuple(params) if params else None)
    if df.empty:
        return df

    def _mk_label(r):
        amt = r.get("AMOUNT") or 0
        dte = r.get("RENEWALDATE")
        try:
            dte_str = pd.to_datetime(dte).date().isoformat() if pd.notna(dte) else "n/a"
        except Exception:
            dte_str = str(dte)
        typ = r.get("INVOICE_TYPE") or "Recurring Invoice"
        return f"{typ} - {r.get('STATUS','')} - {float(amt):.2f} KUSD - {dte_str}"

    df["INVOICE_NAME"] = df.apply(_mk_label, axis=1)
    df["APP_LABEL"] = df.apply(
        lambda r: f"{r['APPLICATIONNAME']}" + (f" ‚Äî {r['SITE']}" if r.get("SITE") else ""),
        axis=1
    )

    df = df.rename(columns={
        "FISCAL_YEAR": "Fiscal Year",
        "RENEWALDATE": "Renewal Date",
        "STATUS": "Status",
        "AMOUNT": "Amount (KUSD)",
        "TEAMNAME": "Team",
        "GROUPNAME": "Application Group",
        "APPLICATIONNAME": "Application",
        "INVOICE_NAME": "Invoice Name",
        "INVOICE_TYPE": "Invoice Type",
        "AGREEMENT_NUMBER": "Agreement Number",
    })
    return df

@st.cache_data(ttl=60, show_spinner=False)
def cached_search_invoices(**kwargs):
    return _search_invoices_enriched(**kwargs)

# --------------------------------------------------------------------------------------
# UI
# --------------------------------------------------------------------------------------
st.title("üßæ Invoice Tracking")

# Two tabs: Create new, Search (with inline Edit)
tab_create, tab_search = st.tabs(["Create new", "Search"])

# =======================================
# TAB ‚Äî Create new
# =======================================
with tab_create:
    st.subheader("Create new invoice")

    if st.session_state.pop("do_reset_create_form", False):
        _reset_create_form_state()

    # Fiscal Year defaults to current year
    this_year = date.today().year
    fy_list_new = _safe_years(2020, 2036)
    fy_idx_new = fy_list_new.index(this_year) if this_year in fy_list_new else 0
    fy_choice_new = st.selectbox("Fiscal Year", options=[str(y) for y in fy_list_new], index=fy_idx_new, key="create_year_sel")
    fiscal_year_new = int(fy_choice_new)

    # Invoice Type
    itype_options = ["Select Invoice Type", "Recurring Invoice", "Ad Hoc Invoice"]
    itype_choice = st.selectbox("Invoice Type", options=itype_options, index=0, key="create_invoice_type")
    invoice_type_new = None if itype_choice == "Select Invoice Type" else itype_choice

    program_id_c, team_id_c, team_name_c, group_id_c, app_id_c = _select_team_group_app("create")

    if all([fiscal_year_new, invoice_type_new, team_id_c, group_id_c, app_id_c]):
        with st.expander("Start entering details", expanded=True):
            with st.form("create_form"):
                values_c = _edit_create_fields("create", loaded_invoice=None, selected_team_name=team_name_c, invoice_type=invoice_type_new)
                values_c.update({
                    "application_id": app_id_c,
                    "team_id": team_id_c,
                    "group_id": group_id_c,
                    "fiscal_year": fiscal_year_new,
                    "product_owner_implicit": values_c["product_owner_implicit"] or None,
                    "invoice_type": invoice_type_new,
                })

                row = st.columns([0.22, 0.22, 0.56])
                with row[0]:
                    save_new_clicked = st.form_submit_button("Save Invoice", type="primary")
                with row[1]:
                    reset_clicked = st.form_submit_button("Reset form", type="secondary")

            if save_new_clicked:
                try:
                    invoice_id_new = str(uuid.uuid4())
                    _save_invoice_and_attachments(invoice_id_new, values_c)
                    st.success("Invoice saved.")
                    st.cache_data.clear()
                except Exception as e:
                    st.error(f"Error saving invoice: {e}")
            if reset_clicked:
                st.session_state["do_reset_create_form"] = True
                st.rerun()
    else:
        st.info("Select Invoice Type ‚Üí Program ‚Üí Team ‚Üí Group ‚Üí Application to create an invoice.")

# =======================================
# TAB ‚Äî Search (cards grid with per-row Edit)
# =======================================
with tab_search:
    st.subheader("Search invoices")

    # (NEW) By default, don't auto-open edit panel when arriving at this tab.
    # It will only open after pressing a row's Edit button.
    if not st.session_state.get("search_keep_open", False):
        _clear_inline_edit_state()

    # Top row filters
    sc1, sc2, sc3, sc4, sc5 = st.columns([1.0, 1.2, 1.4, 1.7, 2.0])

    # Fiscal year (default: current year)
    with sc1:
        years = ["All"] + [str(y) for y in _safe_years(2020, 2036)]
        default_year = str(date.today().year)
        fy_default_idx = years.index(default_year) if default_year in years else 0
        fy_val = st.selectbox("Fiscal Year", options=years, index=fy_default_idx, key="search_fy")
        fy_filter = None if fy_val == "All" else int(fy_val)

    # Program
    with sc2:
        progs = cached_list_programs()
        prog_names = ["All"] + (progs["PROGRAMNAME"].tolist() if not progs.empty else [])
        sel_prog_name = st.selectbox("Program", options=prog_names, index=0, key="search_prog")
        prog_id_s = None
        if sel_prog_name != "All" and not progs.empty:
            prog_id_s = progs.loc[progs["PROGRAMNAME"] == sel_prog_name, "PROGRAMID"].iloc[0]

    # Team
    with sc3:
        teams = cached_list_teams()
        if prog_id_s:
            teams = teams.loc[teams["PROGRAMID"] == prog_id_s]
        team_names = ["All"] + (teams["TEAMNAME"].tolist() if not teams.empty else [])
        sel_team_name = st.selectbox("Team", options=team_names, index=0, key="search_team")
        team_id_s = None
        if sel_team_name != "All" and not teams.empty:
            team_id_s = teams.loc[teams["TEAMNAME"] == sel_team_name, "TEAMID"].iloc[0]

    # Group
    with sc4:
        if team_id_s:
            groups = cached_list_groups_for_team(team_id_s)
        else:
            groups = cached_list_application_groups()
        group_names = ["All"] + (groups["GROUPNAME"].tolist() if not groups.empty else [])
        sel_group_name = st.selectbox("Application Group", options=group_names, index=0, key="search_group")
        group_id_s = None
        if sel_group_name != "All" and not groups.empty:
            group_id_s = groups.loc[groups["GROUPNAME"] == sel_group_name, "GROUPID"].iloc[0]

    # Application
    with sc5:
        if group_id_s:
            apps = cached_list_applications(group_id=group_id_s)
        elif team_id_s:
            apps = cached_list_applications(team_id=team_id_s)
        else:
            apps = cached_list_applications()
        apps = apps.copy()
        if not apps.empty:
            apps["LABEL"] = apps.apply(lambda r: f"{r['APPLICATIONNAME']}" + (f" ‚Äî {r['SITE']}" if r.get("SITE") else ""), axis=1)
        app_labels = ["All"] + (apps["LABEL"].tolist() if not apps.empty else [])
        sel_app_label = st.selectbox("Application Instance", options=app_labels, index=0, key="search_app")
        app_id_s = None
        if sel_app_label != "All" and not apps.empty:
            app_id_s = apps.iloc[apps["LABEL"].tolist().index(sel_app_label)]["APPLICATIONID"]

    # Second row: new filters + ordering
    sc6, sc7, sc8, sc9, sc10, sc11 = st.columns([1.0, 1.2, 1.2, 1.4, 1.2, 1.2])

    with sc6:
        status_opt = st.selectbox("Status", ["All", "Planned", "Completed"], index=0, key="search_status")
        status_filter = None if status_opt == "All" else status_opt

    with sc7:
        itype_opt = st.selectbox("Invoice Type", ["All", "Recurring Invoice", "Ad Hoc Invoice"], index=0, key="search_itype")
        invoice_type_filter = None if itype_opt == "All" else itype_opt

    with sc8:
        agreement_like = st.text_input("Agreement Number contains", value="", key="search_agreement_like")
        agreement_like = agreement_like.strip() or None

    with sc9:
        vends = cached_list_vendors()
        vend_names = ["All"] + (vends["VENDORNAME"].tolist() if not vends.empty else [])
        sel_vend_name = st.selectbox("Vendor", options=vend_names, index=0, key="search_vendor")
        vendor_id_s = None
        if sel_vend_name != "All" and not vends.empty:
            vendor_id_s = vends.loc[vends["VENDORNAME"] == sel_vend_name, "VENDORID"].iloc[0]

    with sc10:
        order_status = st.selectbox("Order by Status", ["None", "Planned first", "Completed first"], index=0, key="search_order_status")
        order_status = None if order_status == "None" else order_status

    with sc11:
        order_date = st.selectbox("Order by Date", ["None", "Newest first", "Oldest first"], index=1, key="search_order_date")
        order_date = None if order_date == "None" else order_date

    # (NEW) Close inline edit when any filter changes
    current_filter_sig = repr([
        fy_filter, prog_id_s, team_id_s, group_id_s, app_id_s,
        status_filter, invoice_type_filter, agreement_like, vendor_id_s,
        order_status, order_date
    ])
    prev_sig = st.session_state.get("search_filter_sig")
    if prev_sig != current_filter_sig:
        st.session_state["search_filter_sig"] = current_filter_sig
        # If filters changed, close inline editor
        st.session_state["search_keep_open"] = False
        _clear_inline_edit_state()

    st.divider()

    # Results (cards grid)
    res = cached_search_invoices(
        fiscal_year=fy_filter,
        program_id=prog_id_s,
        team_id=team_id_s,
        group_id=group_id_s,
        application_id=app_id_s,
        status_filter=status_filter,
        invoice_type_filter=invoice_type_filter,
        agreement_like=agreement_like,
        vendor_id=vendor_id_s,
        order_status=order_status,
        order_date=order_date,
    )

    if res.empty:
        st.info("No invoices match your filters.")
        _clear_inline_edit_state()
    else:
        # Simple pagination
        page_size = 12  # cards per page (grid)
        total = len(res)
        pages = max(1, (total + page_size - 1) // page_size)
        pcol1, pcol2, pcol3 = st.columns([0.2, 0.3, 0.5])
        with pcol1:
            page_num = st.number_input("Page", min_value=1, max_value=pages, value=1, step=1, key="search_page_num")
        with pcol2:
            st.write(f"Showing {1 + (page_num-1)*page_size}-{min(total, page_num*page_size)} of {total}")

        start = (page_num - 1) * page_size
        end = min(total, start + page_size)
        subset = res.iloc[start:end].reset_index(drop=True)

        # Grid: 3 cards per row
    cols_per_row = 3
    rows = (len(subset) + cols_per_row - 1) // cols_per_row

    for r in range(rows):
        start_idx = r * cols_per_row
        end_idx = min(start_idx + cols_per_row, len(subset))
        row_df = subset.iloc[start_idx:end_idx]  # ‚úÖ correct iloc slicing

    # Only create as many columns as we actually have cards for this row
    cols = st.columns(min(cols_per_row, len(row_df)), gap="small")

    for col, (_, rec) in zip(cols, row_df.iterrows()):
        rid = str(rec["INVOICEID"])
        with col:
            st.markdown(
                f"""
                <div style="border:1px solid #eee;border-radius:10px;padding:12px;margin-bottom:8px;">
                  <div style="font-weight:600;margin-bottom:6px;">{rec['Invoice Name']}</div>
                  <div style="font-size:0.92em;opacity:0.85;">
                    <b>Team:</b> {rec['Team']}<br/>
                    <b>Group:</b> {rec['Application Group']}<br/>
                    <b>App:</b> {rec['Application']}<br/>
                    <b>FY:</b> {int(rec['Fiscal Year'])}<br/>
                    <b>Type:</b> {rec.get('Invoice Type','Recurring Invoice')}<br/>
                    <b>Agreement:</b> {rec.get('Agreement Number') or '‚Äî'}
                  </div>
                  <div style="margin-top:8px;">
                """,
                unsafe_allow_html=True
            )
            bcol1, bcol2 = st.columns([0.5, 0.5])
            with bcol1:
                if st.button("‚úèÔ∏è Edit", key=f"edit_btn_{rid}"):
                    _clear_inline_edit_state()
                    st.session_state["search_edit_invoice_id"] = rid
                    st.session_state["search_edit_ctx"] = {
                        "fiscal_year": int(rec["Fiscal Year"]),
                        "team_id": rec["TEAMID"],
                        "group_id": rec["GROUPID"],
                        "application_id": rec["APPLICATIONID"],
                        "team_name": rec["Team"],
                        "group_name": rec["Application Group"],
                        "app_label": rec.get("APP_LABEL") or rec["Application"],
                        "invoice_label": rec["Invoice Name"],
                        "invoice_type": rec.get("Invoice Type") or "Recurring Invoice",
                    }
                    st.session_state["search_keep_open"] = True
                    st.rerun()
            with bcol2:
                st.write("")  # spacer
            st.markdown("</div></div>", unsafe_allow_html=True)


        # Inline edit panel (inside Search) ‚Äî shown only if opened via Edit button
        inv_id = st.session_state.get("search_edit_invoice_id")
        ctx = st.session_state.get("search_edit_ctx")
        if st.session_state.get("search_keep_open") and inv_id and ctx:
            inv_df = cached_fetch_invoice_by_id(inv_id)
            if inv_df.empty:
                st.warning("Selected invoice no longer exists.")
                _clear_inline_edit_state()
                st.session_state["search_keep_open"] = False
            else:
                loaded_invoice = inv_df.iloc[0]
                invoice_type_for_edit = loaded_invoice.get("INVOICE_TYPE") or ctx.get("invoice_type") or "Recurring Invoice"

                st.markdown("---")
                with st.expander(f"Start entering details ‚Äî {ctx.get('invoice_label','')}", expanded=True):
                    with st.form("search_edit_form"):
                        values = _edit_create_fields(
                            "search_edit",
                            loaded_invoice=loaded_invoice,
                            selected_team_name=ctx.get("team_name"),
                            invoice_type=invoice_type_for_edit
                        )
                        values.update({
                            "application_id": ctx["application_id"],
                            "team_id": ctx["team_id"],
                            "group_id": ctx["group_id"],
                            "fiscal_year": ctx["fiscal_year"],
                            "product_owner_implicit": values["product_owner_implicit"] or None,
                            "invoice_type": invoice_type_for_edit,
                        })

                        row = st.columns([0.22, 0.22, 0.56])
                        with row[0]:
                            save_clicked = st.form_submit_button("Save Changes", type="primary")
                        with row[1]:
                            delete_clicked = st.form_submit_button("üóëÔ∏è Delete Invoice", type="secondary", help="This will prompt a confirmation")

                    if save_clicked:
                        try:
                            _save_invoice_and_attachments(inv_id, values)
                            st.success("Invoice updated.")
                            st.cache_data.clear()
                        except Exception as e:
                            st.error(f"Error saving invoice: {e}")

                    if delete_clicked:
                        st.session_state["search_show_delete_confirm"] = True

                    # Notes (Historical)
                    st.markdown("---")
                    st.subheader("Notes (Historical)")
                    with st.expander("Add or view notes for this invoice", expanded=False):
                        note_text = st.text_area("Add a note (appends to history)", value="", key="note_text_search_edit", height=84)
                        nc1, nc2 = st.columns([2, 1])
                        with nc1:
                            created_by = st.text_input("Your name (optional)", value="", key="note_created_by_search_edit")
                        with nc2:
                            st.write("")
                            if st.button("Add Note", key="btn_add_note_search_edit"):
                                try:
                                    _note_append(inv_id, note_text, _ensure_str(created_by))
                                    st.success("Note added.")
                                    st.cache_data.clear()
                                except Exception as e:
                                    st.error(f"Could not add note: {e}")
                        notes_df = _list_notes(inv_id)
                        if notes_df.empty:
                            st.info("No notes yet for this invoice.")
                        else:
                            st.dataframe(notes_df, use_container_width=True, hide_index=True)

                    # Attachments
                    st.subheader("Attachments")
                    with st.expander("View attachments for this invoice", expanded=False):
                        atts_df = _list_attachments(inv_id)
                        if atts_df.empty:
                            st.info("No attachments uploaded for this invoice.")
                        else:
                            st.dataframe(atts_df, use_container_width=True, hide_index=True)

                    # Delete confirmation
                    if st.session_state.get("search_show_delete_confirm"):
                        st.warning("This action **permanently deletes** the selected invoice and cannot be undone.")
                        c1, c2, c3 = st.columns([2, 1, 1])
                        with c1:
                            confirm = st.checkbox("I understand and want to delete this invoice.",
                                                  key="search_confirm_delete_checkbox")
                        with c2:
                            if st.button("Confirm Delete", type="primary", key="btn_confirm_delete_search"):
                                if not confirm:
                                    st.error("Please confirm by checking the box before deleting.")
                                else:
                                    try:
                                        delete_invoice(inv_id)
                                        st.success("Invoice deleted.")
                                        st.cache_data.clear()
                                        _clear_inline_edit_state()
                                        st.session_state["search_keep_open"] = False
                                        st.rerun()
                                    except Exception as e:
                                        st.error(f"Failed to delete invoice: {e}")
                        with c3:
                            if st.button("Cancel", key="btn_cancel_delete_search"):
                                st.session_state["search_show_delete_confirm"] = False
