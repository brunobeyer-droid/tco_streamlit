# Edit.py  ‚Äî Advanced admin page (danger zone)
import uuid
import streamlit as st
import datetime as dt
from typing import Optional, Tuple

from snowflake_db import (
    ensure_tables as _ensure_tables,
    fetch_df, execute,
    upsert_program,   delete_program,
    upsert_team,      delete_team,
    upsert_vendor,    delete_vendor,
    # upsert_application,  # not exported by snowflake_db; not used in this page
    delete_application,
    # upsert_invoice,      # imported originally but not used in this page
    # rollover_year, list_rollovers, rollback_rollover,  # provide local helpers below
    _read_snowflake_secrets, _fq,  # internal helpers to build FQ table names
)

# Optional sidebar helper; fall back safely if not present
try:
    from utils.sidebar import render_global_actions
except Exception:
    def render_global_actions():
        pass

st.set_page_config(page_title="Bulk Edit (Advanced)", page_icon="‚úèÔ∏è", layout="wide")
render_global_actions()

# Ensure schema once per session
if "_tco_init" not in st.session_state:
    _ensure_tables()
    st.session_state["_tco_init"] = True

# ----------------------------
# Local helpers for rollover
# ----------------------------
def _db() -> Tuple[str, str]:
    cfg = _read_snowflake_secrets()
    return cfg.get("database", "TCODB"), cfg.get("schema", "PUBLIC")

def rollover_year(from_year: int, to_year: int, created_by: Optional[str] = None) -> Tuple[str, int]:
    """
    Create 'Planned' invoices for `to_year` by copying rows from `from_year`.

    CHANGES:
    - Rolls over ONLY Recurring invoices:
      COALESCE(i.INVOICE_TYPE,'Recurring Invoice') = 'Recurring Invoice'
    - Sets INVOICE_TYPE on new rows to 'Recurring Invoice'
    - Uses COALESCE(AMOUNT_NEXT_YEAR, AMOUNT) and shifts RENEWALDATE by year delta.
    - Tags new rows with ROLLOVER_BATCH_ID and ROLLED_OVER_FROM_YEAR so we can undo.
    """
    batch_id = str(uuid.uuid4())
    year_delta = int(to_year) - int(from_year)

    # Insert new invoices (Recurring only)
    insert_sql = f"""
        INSERT INTO { _fq('INVOICES') } (
            INVOICEID, APPLICATIONID, TEAMID,
            INVOICEDATE, RENEWALDATE, AMOUNT, STATUS, FISCAL_YEAR,
            PRODUCT_OWNER, AMOUNT_NEXT_YEAR, CONTRACT_ACTIVE,
            COMPANY_CODE, COST_CENTER, SERIAL_NUMBER, WORK_ORDER, AGREEMENT_NUMBER,
            CONTRACT_DUE, SERVICE_TYPE, NOTES,
            GROUPID, PROGRAMID_AT_BOOKING, VENDORID_AT_BOOKING, GROUPID_AT_BOOKING,
            ROLLOVER_BATCH_ID, ROLLED_OVER_FROM_YEAR,
            INVOICE_TYPE
        )
        SELECT
            UUID_STRING(), i.APPLICATIONID, i.TEAMID,
            /* keep INVOICEDATE NULL for planned rows */ NULL,
            /* shift renewal date by year_delta if present */
            CASE WHEN i.RENEWALDATE IS NOT NULL THEN DATEADD(year, {year_delta}, i.RENEWALDATE) ELSE NULL END,
            COALESCE(i.AMOUNT_NEXT_YEAR, i.AMOUNT) AS AMOUNT,
            'Planned' AS STATUS,
            %s AS FISCAL_YEAR,
            i.PRODUCT_OWNER,
            i.AMOUNT_NEXT_YEAR,
            /* planned rows default to contract_active unless explicitly set */ COALESCE(i.CONTRACT_ACTIVE, TRUE),
            i.COMPANY_CODE, i.COST_CENTER, i.SERIAL_NUMBER, i.WORK_ORDER, i.AGREEMENT_NUMBER,
            i.CONTRACT_DUE, i.SERVICE_TYPE, i.NOTES,
            i.GROUPID, i.PROGRAMID_AT_BOOKING, i.VENDORID_AT_BOOKING, i.GROUPID_AT_BOOKING,
            %s AS ROLLOVER_BATCH_ID,
            %s AS ROLLED_OVER_FROM_YEAR,
            /* ensure the new rows are explicitly marked as Recurring */
            'Recurring Invoice' AS INVOICE_TYPE
        FROM { _fq('INVOICES') } i
        WHERE i.FISCAL_YEAR = %s
          AND COALESCE(i.INVOICE_TYPE, 'Recurring Invoice') = 'Recurring Invoice'
    """
    # FISCAL_YEAR (to), BATCH, FROM_YEAR, FROM_YEAR
    execute(insert_sql, (int(to_year), batch_id, int(from_year), int(from_year)))

    # Count inserted
    cnt_df = fetch_df(f"SELECT COUNT(*) AS CNT FROM { _fq('INVOICES') } WHERE ROLLOVER_BATCH_ID = %s", (batch_id,))
    inserted = int(cnt_df.iloc[0]["CNT"]) if not cnt_df.empty else 0

    # Log the batch
    log_sql = f"""
        INSERT INTO { _fq('ROLLOVER_LOG') } (BATCH_ID, FROM_YEAR, TO_YEAR, ROWS_INSERTED, CREATED_BY)
        VALUES (%s, %s, %s, %s, %s)
    """
    execute(log_sql, (batch_id, int(from_year), int(to_year), inserted, created_by))
    return batch_id, inserted

def list_rollovers():
    return fetch_df(f"""
        SELECT BATCH_ID, FROM_YEAR, TO_YEAR, ROWS_INSERTED, CREATED_AT, CREATED_BY
        FROM { _fq('ROLLOVER_LOG') }
        ORDER BY CREATED_AT DESC
    """)

def rollback_rollover(batch_id: str) -> int:
    """
    Delete invoices created by a specific rollover batch.
    (No change needed for invoice types‚Äîbatch id targets only the rows created by rollover,
    which we now ensure are Recurring.)
    """
    # How many rows will we delete?
    cnt_df = fetch_df(f"SELECT COUNT(*) AS CNT FROM { _fq('INVOICES') } WHERE ROLLOVER_BATCH_ID = %s", (batch_id,))
    to_delete = int(cnt_df.iloc[0]["CNT"]) if not cnt_df.empty else 0
    # Delete invoices first, then the log entry
    execute(f"DELETE FROM { _fq('INVOICES') } WHERE ROLLOVER_BATCH_ID = %s", (batch_id,))
    execute(f"DELETE FROM { _fq('ROLLOVER_LOG') } WHERE BATCH_ID = %s", (batch_id,))
    return to_delete

# ----------------------------
# UI
# ----------------------------
st.title("‚úèÔ∏è Bulk Edit (Advanced)")
st.caption("Careful! These operations directly modify or delete records.")

# ---------- Quick viewers (read-only) ----------
colA, colB = st.columns(2)
with colA:
    st.subheader("Programs")
    st.dataframe(
        fetch_df("SELECT PROGRAMID, PROGRAMNAME, PROGRAMOWNER, PROGRAMFTE FROM PROGRAMS ORDER BY PROGRAMNAME"),
        use_container_width=True, height=240
    )
with colB:
    st.subheader("Teams")
    st.dataframe(
        fetch_df("SELECT TEAMID, TEAMNAME, PROGRAMID, TEAMFTE, COSTPERFTE FROM TEAMS ORDER BY TEAMNAME"),
        use_container_width=True, height=240
    )

colC, colD = st.columns(2)
with colC:
    st.subheader("Vendors")
    st.dataframe(
        fetch_df("SELECT VENDORID, VENDORNAME FROM VENDORS ORDER BY VENDORNAME"),
        use_container_width=True, height=240
    )
with colD:
    st.subheader("Applications")
    st.dataframe(
        fetch_df("""
            SELECT
              A.APPLICATIONID,
              A.APPLICATIONNAME,
              A.VENDORID,
              V.VENDORNAME
            FROM APPLICATIONS A
            LEFT JOIN VENDORS V ON V.VENDORID = A.VENDORID
            ORDER BY A.APPLICATIONNAME
        """),
        use_container_width=True, height=240
    )

st.divider()

# ---------- Invoices viewer (read-only) ----------
st.subheader("Invoices (read-only)")
inv_view = fetch_df("""
    SELECT
      i.INVOICEID,
      i.FISCAL_YEAR,
      i.INVOICEDATE,
      i.RENEWALDATE,
      i.AMOUNT,
      i.STATUS,
      COALESCE(i.INVOICE_TYPE,'Recurring Invoice') AS INVOICE_TYPE,
      t.TEAMNAME,
      p.PROGRAMNAME,
      a.APPLICATIONNAME,
      v.VENDORNAME
    FROM INVOICES i
    LEFT JOIN TEAMS t ON t.TEAMID = i.TEAMID
    LEFT JOIN PROGRAMS p ON p.PROGRAMID = COALESCE(i.PROGRAMID_AT_BOOKING, t.PROGRAMID)
    LEFT JOIN APPLICATIONS a ON a.APPLICATIONID = i.APPLICATIONID
    LEFT JOIN VENDORS v ON v.VENDORID = COALESCE(i.VENDORID_AT_BOOKING, a.VENDORID)
    ORDER BY i.INVOICEDATE DESC
""")
if inv_view.empty:
    st.info("No invoices found.")
else:
    st.dataframe(inv_view, use_container_width=True, height=340)

    # --- Quick copy helper for Invoice IDs ---
    st.markdown("**Quick copy an Invoice ID**")
    inv_copy_df = inv_view.copy()
    inv_copy_df["LABEL"] = inv_copy_df.apply(
        lambda r: f"{str(r['INVOICEID'])[:8]}‚Ä¶  |  {r.get('APPLICATIONNAME') or 'N/A'}  |  {r.get('TEAMNAME') or 'N/A'}  |  {r.get('INVOICE_TYPE')}  |  {r.get('INVOICEDATE')}",
        axis=1,
    )
    if not inv_copy_df.empty:
        pick = st.selectbox("Pick an invoice", inv_copy_df["LABEL"].tolist())
        chosen_id = inv_copy_df.loc[inv_copy_df["LABEL"] == pick, "INVOICEID"].iloc[0]
        st.caption("Click the copy icon on the code box to copy the ID:")
        st.code(str(chosen_id))

st.divider()

# ---------- Year Rollover tool ----------
with st.expander("üîÅ Rollover Planned Invoices to Next Year", expanded=False):
    st.write("Creates **Planned** invoices for the next fiscal year from last year's values "
             "(uses `AMOUNT_NEXT_YEAR` when present, otherwise `AMOUNT`). "
             "Only **Recurring** invoices are rolled over. "
             "Every rollover is tagged with a **batch id** so it can be undone later.")
    this_year = dt.date.today().year
    from_year = st.number_input("From fiscal year", value=this_year, step=1, format="%d")
    to_year   = st.number_input("To fiscal year",   value=this_year + 1, step=1, format="%d")
    created_by = st.text_input("Created by (optional)", value="streamlit")
    if st.button("Generate next year's planned invoices"):
        if to_year <= from_year:
            st.error("`To fiscal year` must be greater than `From fiscal year`.")
        else:
            batch_id, inserted = rollover_year(int(from_year), int(to_year), created_by=created_by or None)
            st.success(f"Batch {batch_id[:8]}‚Ä¶ created {inserted} planned recurring invoice(s) for {to_year}.")
            st.caption("You can undo this batch below in **Undo a Rollover Batch**.")
            st.cache_data.clear()

st.divider()

# ---------- Undo a Rollover (safe rollback) ----------
with st.expander("‚Ü©Ô∏è Undo a Rollover Batch", expanded=False):
    logs = list_rollovers()

    # Manual rollback (works even if no batches show up below)
    st.markdown("**Manual rollback by Batch ID**")
    mcol1, mcol2 = st.columns([3, 1])
    with mcol1:
        manual_batch_id = st.text_input("Enter Batch ID (paste full ID)")
    with mcol2:
        if st.button("Rollback (Manual)"):
            if not manual_batch_id.strip():
                st.error("Please paste a Batch ID.")
            else:
                deleted = rollback_rollover(manual_batch_id.strip())
                st.success(f"Rolled back {deleted} invoice(s) from batch {manual_batch_id[:8]}‚Ä¶")
                st.cache_data.clear()

    st.markdown("---")

    # Guided rollback (select from the log)
    st.markdown("**Rollback from recent batches**")
    if logs.empty:
        st.info("No rollover batches found yet. Run a rollover first, or use the manual rollback above.")
    else:
        # Friendly label: <batch_id short> | from‚Üíto | rows | time
        logs = logs.copy()
        logs["LABEL"] = logs.apply(
            lambda r: f"{str(r['BATCH_ID'])[:8]}‚Ä¶  |  {int(r['FROM_YEAR'])} ‚Üí {int(r['TO_YEAR'])}  |  {int(r['ROWS_INSERTED'])} rows  |  {r['CREATED_AT']}",
            axis=1
        )
        pick = st.selectbox("Rollover Batches", logs["LABEL"].tolist())
        sel = logs.loc[logs["LABEL"] == pick].iloc[0]
        batch_id = sel["BATCH_ID"]

        # Preview rows in this batch
        preview = fetch_df("SELECT * FROM INVOICES WHERE ROLLOVER_BATCH_ID = %s ORDER BY INVOICEDATE", (batch_id,))
        if preview.empty:
            st.warning("No invoices found for this batch (maybe already rolled back).")
        else:
            st.dataframe(preview, use_container_width=True, height=300)

        st.warning("Rollback deletes ONLY invoices created by this batch. Other data is untouched.")
        if st.button("‚ö†Ô∏è Rollback this selected batch"):
            deleted = rollback_rollover(batch_id)
            st.success(f"Rolled back {deleted} invoice(s) from batch {batch_id[:8]}‚Ä¶")
            st.cache_data.clear()

st.divider()

# ---------- Delete Program (cascade Teams -> Invoices) ----------
with st.expander("üóëÔ∏è Delete Program (and its child Teams & Invoices)", expanded=False):
    st.write("Deletes all Invoices under Teams that belong to the Program, then deletes those Teams, then the Program.")
    prog_id = st.text_input("ProgramID to delete")
    if st.button("Delete Program & children"):
        if not prog_id.strip():
            st.error("Please provide a ProgramID.")
        else:
            teams = fetch_df("SELECT TEAMID FROM TEAMS WHERE PROGRAMID = %s", (prog_id,))
            for _, tr in teams.iterrows():
                invs = fetch_df("SELECT INVOICEID FROM INVOICES WHERE TEAMID = %s", (tr["TEAMID"],))
                for __, ir in invs.iterrows():
                    execute("DELETE FROM INVOICES WHERE INVOICEID = %s", (ir["INVOICEID"],))
                delete_team(tr["TEAMID"])
            delete_program(prog_id)
            st.success("Program and children deleted.")
            st.cache_data.clear()

# ---------- Delete Team by TeamID (and its Invoices) ----------
with st.expander("üóëÔ∏è Delete Team by TeamID (and its Invoices)", expanded=False):
    st.write("Deletes all Invoices that reference the Team, then deletes the Team record.")
    team_id_to_del = st.text_input("TeamID to delete")
    if st.button("Delete Team & its invoices"):
        if not team_id_to_del.strip():
            st.error("Please provide a TeamID.")
        else:
            invs = fetch_df("SELECT INVOICEID FROM INVOICES WHERE TEAMID = %s", (team_id_to_del,))
            for _, ir in invs.iterrows():
                execute("DELETE FROM INVOICES WHERE INVOICEID = %s", (ir["INVOICEID"],))
            delete_team(team_id_to_del)
            st.success("Team and its invoices deleted.")
            st.cache_data.clear()

# ---------- Delete Application (and its Invoices) ----------
with st.expander("üóëÔ∏è Delete Application (and its Invoices)", expanded=False):
    st.write("Deletes all Invoices that reference the Application, then deletes the Application.")
    app_id = st.text_input("ApplicationID to delete")
    if st.button("Delete Application & its invoices"):
        if not app_id.strip():
            st.error("Please provide an ApplicationID.")
        else:
            invs = fetch_df("SELECT INVOICEID FROM INVOICES WHERE APPLICATIONID = %s", (app_id,))
            for _, ir in invs.iterrows():
                execute("DELETE FROM INVOICES WHERE INVOICEID = %s", (ir["INVOICEID"],))
            delete_application(app_id)
            st.success("Application and invoices deleted.")
            st.cache_data.clear()

# ---------- Delete Vendor (and orphan Applications) ----------
with st.expander("üóëÔ∏è Delete Vendor (and orphan Applications)", expanded=False):
    st.write("Deletes Applications for this Vendor only if they have no Invoices; then deletes the Vendor.")
    vend_id = st.text_input("VendorID to delete")
    if st.button("Delete Vendor & orphan applications"):
        if not vend_id.strip():
            st.error("Please provide a VendorID.")
        else:
            apps = fetch_df("""
                SELECT a.APPLICATIONID
                FROM APPLICATIONS a
                LEFT JOIN INVOICES i ON i.APPLICATIONID = a.APPLICATIONID
                WHERE a.VENDORID = %s AND i.INVOICEID IS NULL
            """, (vend_id,))
            for _, ar in apps.iterrows():
                delete_application(ar["APPLICATIONID"])
            delete_vendor(vend_id)
            st.success("Vendor and orphan applications deleted.")
            st.cache_data.clear()

# ---------- Delete Invoice by ID (with preview + copy) ----------
with st.expander("üóëÔ∏è Delete Invoice by ID", expanded=False):
    st.write("Preview the invoice, copy its ID if needed, then delete by **INVOICEID**.")
    inv_id = st.text_input("InvoiceID to preview/delete")

    preview = None
    if inv_id.strip():
        preview = fetch_df("""
            SELECT
              i.INVOICEID,
              i.FISCAL_YEAR,
              i.INVOICEDATE,
              i.RENEWALDATE,
              i.AMOUNT,
              i.STATUS,
              COALESCE(i.INVOICE_TYPE,'Recurring Invoice') AS INVOICE_TYPE,
              t.TEAMNAME,
              p.PROGRAMNAME,
              a.APPLICATIONNAME,
              v.VENDORNAME
            FROM INVOICES i
            LEFT JOIN TEAMS t ON t.TEAMID = i.TEAMID
            LEFT JOIN PROGRAMS p ON p.PROGRAMID = COALESCE(i.PROGRAMID_AT_BOOKING, t.PROGRAMID)
            LEFT JOIN APPLICATIONS a ON a.APPLICATIONID = i.APPLICATIONID
            LEFT JOIN VENDORS v ON v.VENDORID = COALESCE(i.VENDORID_AT_BOOKING, a.VENDORID)
            WHERE i.INVOICEID = %s
        """, (inv_id.strip(),))

    if preview is not None and not preview.empty:
        st.dataframe(preview, use_container_width=True)
        st.caption("Copy this InvoiceID:")
        st.code(inv_id.strip())
        if st.button("Delete This Invoice"):
            execute("DELETE FROM INVOICES WHERE INVOICEID = %s", (inv_id.strip(),))
            st.success("Invoice deleted.")
            st.cache_data.clear()
    elif inv_id.strip():
        st.warning("Invoice not found. Please check the ID and try again.")

st.divider()

# ---------- Raw SQL (read-only SELECT) ----------
st.subheader("Raw SQL (read-only)")
user_sql = st.text_area(
    "Run a SELECT (for diagnostic reads). Non-SELECT statements are blocked here.",
    value="SELECT CURRENT_USER() AS USER, CURRENT_ROLE() AS ROLE, CURRENT_DATABASE() AS DB, CURRENT_SCHEMA() AS SCHEMA;"
)
if st.button("Run SELECT"):
    sql_up = user_sql.strip().upper()
    if not sql_up.startswith("SELECT"):
        st.error("Only SELECT statements are allowed in this box.")
    else:
        try:
            st.dataframe(fetch_df(user_sql), use_container_width=True)
        except Exception as e:
            st.error(e)
