# pages/applications.py
import streamlit as st
import uuid
import pandas as pd  # used for lightweight row reordering after save
from typing import Optional

# If your DB lives under utils/, change to: from utils.snowflake_db import ...
from snowflake_db import (
    ensure_tables, fetch_df,
    list_application_groups, list_applications, list_teams, list_groups_for_team,
    upsert_application_group, upsert_application_instance,
    delete_application_group, delete_application,
)

try:
    from utils.sidebar import render_global_actions
except Exception:
    def render_global_actions(): pass

st.set_page_config(page_title="Applications", page_icon="üóÇÔ∏è", layout="wide")
render_global_actions()

# =========================================================
# One-time setup per session (avoid running on every rerun)
# =========================================================
if "tables_ok" not in st.session_state:
    ensure_tables()
    st.session_state["tables_ok"] = True

# Version tokens so we can invalidate *specific* cached reads
st.session_state.setdefault("ver_programs_teams", 0)  # programs/teams/groups-for-team lists
st.session_state.setdefault("ver_groups_listing", 0)  # only the groups table at the bottom
st.session_state.setdefault("ver_apps_listing", 0)    # instances table

def bump_version(which: str):
    st.session_state[which] += 1

ver_pt = st.session_state["ver_programs_teams"]
ver_groups = st.session_state["ver_groups_listing"]
ver_apps = st.session_state["ver_apps_listing"]

st.title("üóÇÔ∏è Applications")

# -----------------------------
# Cached helpers (fast reads)
# -----------------------------
@st.cache_data(ttl=180, show_spinner=False)
def _vendors_df(_ver: int):
    return fetch_df("SELECT VENDORID, VENDORNAME FROM VENDORS ORDER BY VENDORNAME")

@st.cache_data(ttl=180, show_spinner=False)
def _programs_df(_ver: int):
    return fetch_df("SELECT PROGRAMID, PROGRAMNAME FROM PROGRAMS ORDER BY PROGRAMNAME")

@st.cache_data(ttl=180, show_spinner=False)
def _teams_for_program(program_id: Optional[str], _ver: int):
    """
    Prefer narrowing Teams to the selected Program (assumes TEAMS.PROGRAMID exists).
    Falls back to list_teams() if no program or query fails.
    """
    if not program_id:
        return list_teams()
    try:
        q = f"""
        SELECT TEAMID, TEAMNAME, PROGRAMID
        FROM TEAMS
        WHERE PROGRAMID = '{program_id}'
        ORDER BY TEAMNAME
        """
        df = fetch_df(q)
        if df is not None and not df.empty:
            return df
    except Exception:
        pass
    return list_teams()

@st.cache_data(ttl=180, show_spinner=False)
def _groups_for_team(team_id: str, _ver: int):
    return list_groups_for_team(team_id)

@st.cache_data(ttl=120, show_spinner=False)
def _groups_listing(_ver_groups_only: int):
    # This cache is invalidated *only* when we bump ver_groups
    return list_application_groups()

@st.cache_data(ttl=120, show_spinner=False)
def _apps_listing(team_id: str, _ver_apps_only: int):
    # This cache is invalidated *only* when we bump ver_apps
    return list_applications(team_id=team_id)

# ---- Uniqueness helpers (global, case-insensitive) ----
@st.cache_data(ttl=120, show_spinner=False)
def _all_group_names_upper(_ver: int) -> set[str]:
    df = fetch_df("SELECT GROUPNAME FROM APPLICATION_GROUPS")
    if df is None or df.empty or "GROUPNAME" not in df.columns:
        return set()
    return set(df["GROUPNAME"].dropna().astype(str).str.strip().str.upper().tolist())

@st.cache_data(ttl=120, show_spinner=False)
def _all_application_names_upper(_ver: int) -> set[str]:
    df = fetch_df("SELECT APPLICATIONNAME FROM APPLICATIONS")
    if df is None or df.empty or "APPLICATIONNAME" not in df.columns:
        return set()
    return set(df["APPLICATIONNAME"].dropna().astype(str).str.strip().str.upper().tolist())

# -----------------------------
# Small utilities
# -----------------------------
def _safe_first_value(df, col) -> Optional[str]:
    if df is None or df.empty or col not in df.columns:
        return None
    try:
        return df[col].iloc[0]
    except Exception:
        return None

def _lookup_id_by_name(df, name_col: str, id_col: str, name_value: str) -> Optional[str]:
    if df is None or df.empty or name_col not in df.columns or id_col not in df.columns:
        return None
    rows = df[df[name_col] == name_value]
    if rows.empty:
        return None
    try:
        return rows[id_col].iloc[0]
    except Exception:
        return None

# selectbox with "(select)" placeholder
def _select_with_placeholder(label: str, options: list[str], key: str, disabled: bool = False) -> Optional[str]:
    opts = ["(select)"] + options
    choice = st.selectbox(label, options=opts, key=key, disabled=disabled, index=0)
    if choice == "(select)":
        return None
    return choice

# Tabs
grp_tab, inst_tab = st.tabs(["Groups (Program ‚Üí Team)", "Instances (Program ‚Üí Team ‚Üí Group)"])

# =========================
# Groups tab
# =========================
with grp_tab:
    st.subheader("Create / Edit Group")

    programs = _programs_df(ver_pt)
    if programs is None or programs.empty:
        st.warning("Create Programs first (see Programs page).")
        selected_program_label = None
        selected_program_id = None
    else:
        programs["LABEL"] = programs["PROGRAMNAME"].astype(str)
        selected_program_label = _select_with_placeholder(
            "Program (required)",
            programs["LABEL"].tolist(),
            key="grp_program_select",
        )
        selected_program_id = _lookup_id_by_name(programs, "LABEL", "PROGRAMID", selected_program_label) if selected_program_label else None

    teams = _teams_for_program(selected_program_id, ver_pt) if selected_program_id else None
    if teams is not None and not teams.empty:
        teams["LABEL"] = teams["TEAMNAME"].astype(str)
    selected_team_label = _select_with_placeholder(
        "Team (required)",
        teams["LABEL"].tolist() if teams is not None and not teams.empty else [],
        key="grp_team_select",
        disabled=selected_program_id is None,
    )
    selected_team_id = _lookup_id_by_name(teams, "LABEL", "TEAMID", selected_team_label) if selected_team_label else None

    vendors = _vendors_df(ver_pt)
    vendor_label = _select_with_placeholder(
        "Vendor (required)",
        vendors["VENDORNAME"].dropna().astype(str).tolist() if vendors is not None and not vendors.empty else [],
        key="grp_vendor_select",
        disabled=selected_team_id is None,
    )
    vendor_id = _lookup_id_by_name(vendors, "VENDORNAME", "VENDORID", vendor_label) if vendor_label else None

    # Context chip (what you're filtering by) ‚Äî now includes Vendor
    st.caption(
        "You‚Äôre viewing Groups for: "
        f"**{selected_program_label or '‚Äî'}** ‚Üí **{selected_team_label or '‚Äî'}** ‚Üí **{vendor_label or '‚Äî'}**"
    )

    # Use a form so typing/selecting doesn't cause mid-edit reruns
    with st.form(key="grp_form", clear_on_submit=True):
        group_name = st.text_input("Group Name (e.g., MHM)", key="grp_name_input", disabled=selected_team_id is None)

        submitted = st.form_submit_button("üíæ Save Group")
        if submitted:
            if not group_name.strip():
                st.error("Group Name is required.")
            elif not selected_program_id:
                st.error("Program is required.")
            elif not selected_team_id:
                st.error("Team is required.")
            elif not vendor_id:
                st.error("Vendor is required.")
            else:
                # Uniqueness checks (case-insensitive, global)
                name_upper = group_name.strip().upper()
                group_names = _all_group_names_upper(ver_groups)          # current groups
                app_names = _all_application_names_upper(ver_apps)        # current applications
                if name_upper in group_names:
                    st.error(f"Group name '{group_name.strip()}' already exists.")
                elif name_upper in app_names:
                    st.error(f"Group name '{group_name.strip()}' conflicts with an existing Application name.")
                else:
                    try:
                        new_group_id = str(uuid.uuid4())
                        upsert_application_group(
                            group_id=new_group_id,
                            group_name=group_name.strip(),
                            team_id=selected_team_id,       # Team belongs to chosen Program
                            default_vendor_id=vendor_id,
                            owner=None,                     # moved to Teams; no Group owner
                        )
                        st.session_state["last_group_saved_id"] = new_group_id
                        bump_version("ver_groups_listing")
                        st.success("Group saved.")
                        st.rerun()
                    except Exception as e:
                        st.error(f"Save failed: {e}")

    st.markdown("---")
    st.subheader("Existing Groups")

    groups = _groups_listing(ver_groups)
    if groups is not None and not groups.empty:
        # Filter by Program and Team (existing behavior)
        if selected_program_label is not None and "PROGRAMNAME" in groups.columns:
            groups = groups[groups["PROGRAMNAME"] == selected_program_label]
        if selected_team_label is not None and "TEAMNAME" in groups.columns:
            groups = groups[groups["TEAMNAME"] == selected_team_label]
        # NEW: Also filter by selected Vendor (refreshes on vendor change)
        if vendor_label is not None and "VENDORNAME" in groups.columns:
            groups = groups[groups["VENDORNAME"] == vendor_label]

        # Drop GROUPID as requested
        show = ["GROUPNAME", "TEAMNAME", "VENDORNAME", "CREATED_AT"]
        show = [c for c in show if c in groups.columns]

        # If we just created a group, bring it to the top for immediate feedback
        last_id = st.session_state.get("last_group_saved_id")
        if last_id and "GROUPID" in groups.columns:
            try:
                top = groups[groups["GROUPID"] == last_id]
                rest = groups[groups["GROUPID"] != last_id]
                groups = pd.concat([top, rest], ignore_index=True)
            except Exception:
                pass

        if groups.empty:
            st.info("No groups match the current selection.")
        else:
            st.dataframe(groups[show], use_container_width=True, hide_index=True)
    else:
        st.info("No groups yet.")

    # ---------- ‚úèÔ∏è Rename Group (by Group NAME within current Team) ----------
    with st.expander("‚úèÔ∏è Rename a Group"):
        # Limit selection to current Team to avoid name dupes across teams
        team_groups = _groups_for_team(selected_team_id, ver_pt) if selected_team_id else None
        if team_groups is None or team_groups.empty:
            st.info("No groups available for this Team.")
        else:
            team_groups = team_groups.sort_values(by="GROUPNAME")
            rename_group_name = _select_with_placeholder(
                "Select Group to rename",
                team_groups["GROUPNAME"].astype(str).tolist(),
                key="grp_rename_select",
            )
            new_group_name = st.text_input(
                "New Group Name",
                key="grp_rename_new_name",
                disabled=rename_group_name is None
            )
            if st.button("Rename Group", key="grp_rename_btn", disabled=rename_group_name is None):
                try:
                    gid = _safe_first_value(team_groups[team_groups["GROUPNAME"] == rename_group_name], "GROUPID")
                    # Keep same team and default vendor; only change name
                    team_id_for_gid = _safe_first_value(team_groups[team_groups["GROUPNAME"] == rename_group_name], "TEAMID")
                    vendor_id_for_gid = _safe_first_value(team_groups[team_groups["GROUPNAME"] == rename_group_name], "VENDORID")
                    if not gid or not new_group_name.strip():
                        st.error("Please select a group and enter a new name.")
                    else:
                        upsert_application_group(
                            group_id=str(gid),
                            group_name=new_group_name.strip(),
                            team_id=str(team_id_for_gid) if team_id_for_gid else None,
                            default_vendor_id=str(vendor_id_for_gid) if vendor_id_for_gid else None,
                            owner=None,
                        )
                        bump_version("ver_groups_listing")
                        st.success("Group renamed.")
                        st.rerun()
                except Exception as e:
                    st.error(f"Rename failed: {e}")

    # ---------- Danger zone: delete by Group NAME (not ID) ----------
    with st.expander("Danger zone: Delete a Group"):
        st.caption("‚ö†Ô∏è Deleting a group is permanent. You can only delete a group with no application instances.")
        # Limit deletion choices to groups in the currently selected Team to avoid duplicates across teams
        team_groups = _groups_for_team(selected_team_id, ver_pt) if selected_team_id else None

        if team_groups is None or team_groups.empty:
            st.info("No groups available for this Team.")
        else:
            team_groups = team_groups.sort_values(by="GROUPNAME")
            del_group_name = _select_with_placeholder(
                "Select Application Group to delete",
                team_groups["GROUPNAME"].astype(str).tolist(),
                key="grp_delete_by_name",
            )
            confirm = st.text_input("Type DELETE to confirm", key="grp_delete_confirm_name", disabled=del_group_name is None)
            st.markdown("**‚ö†Ô∏è This action cannot be undone.**")
            if st.button("üóëÔ∏è Delete Group", key="grp_delete_btn_name", disabled=del_group_name is None):
                if confirm.strip().upper() != "DELETE":
                    st.error("Type DELETE to confirm.")
                else:
                    try:
                        gid = _safe_first_value(team_groups[team_groups["GROUPNAME"] == del_group_name], "GROUPID")
                        if not gid:
                            st.error("Could not find the selected group.")
                        else:
                            delete_application_group(str(gid))
                            bump_version("ver_groups_listing")
                            st.success(f"‚úÖ Group '{del_group_name}' deleted.")
                            st.rerun()
                    except Exception as e:
                        st.error(f"Delete failed: {e}")

# =========================
# Instances tab
# =========================
with inst_tab:
    st.subheader("Create / Edit Application Instance")

    programs = _programs_df(ver_pt)
    if programs is None or programs.empty:
        st.warning("Create Programs first (see Programs page).")
        st.stop()

    programs["LABEL"] = programs["PROGRAMNAME"].astype(str)
    selected_program_label_i = _select_with_placeholder(
        "Program (required)",
        programs["LABEL"].tolist(),
        key="inst_program_select",
    )
    selected_program_id_i = _lookup_id_by_name(programs, "LABEL", "PROGRAMID", selected_program_label_i) if selected_program_label_i else None
    if not selected_program_id_i:
        st.stop()

    teams = _teams_for_program(selected_program_id_i, ver_pt)
    if teams is None or teams.empty:
        st.warning("No Teams found for this Program. Create/assign Teams to this Program first.")
        st.stop()

    teams["LABEL"] = teams["TEAMNAME"].astype(str)
    selected_team_label_i = _select_with_placeholder(
        "Team (required)",
        teams["LABEL"].tolist(),
        key="inst_team_select",
    )
    selected_team_id_i = _lookup_id_by_name(teams, "LABEL", "TEAMID", selected_team_label_i) if selected_team_label_i else None
    if not selected_team_id_i:
        st.stop()

    groups_for_team = _groups_for_team(selected_team_id_i, ver_pt)
    if groups_for_team is None or groups_for_team.empty:
        st.info("No groups found for this Team. Create one in the Groups tab.")
        st.stop()

    groups_for_team["LABEL"] = groups_for_team["GROUPNAME"].astype(str)
    selected_group_label = _select_with_placeholder(
        "Group (owned by Team)",
        groups_for_team["LABEL"].tolist(),
        key="inst_group_select",
    )
    group_row = groups_for_team[groups_for_team["LABEL"] == selected_group_label] if selected_group_label else None
    group_id = _safe_first_value(group_row, "GROUPID") if group_row is not None else None
    if group_id is None:
        st.stop()

    # Pull group's default vendor if available; otherwise None
    vendor_id = _safe_first_value(group_row, "VENDORID")

    # Context chip
    st.caption(
        "You‚Äôre viewing Instances for: "
        f"**{selected_program_label_i or '‚Äî'}** ‚Üí **{selected_team_label_i or '‚Äî'}** ‚Üí **{selected_group_label or '‚Äî'}**"
    )

    # Use a form so typing doesn't trigger expensive reruns
    with st.form(key="inst_form", clear_on_submit=True):
        c1, c2 = st.columns(2)
        with c1:
            # Label only; we generate the canonical Application Name from Group + Instance
            application_instance = st.text_input("Application Instance (e.g., Baytown)", key="inst_app_name")
        with c2:
            # Renamed from "Site" -> "Additional Info (optional)"
            add_info = st.text_input("Additional Info (optional)", placeholder="Optional", key="inst_add_info")

        submitted = st.form_submit_button("üíæ Save Instance")
        if submitted:
            if not application_instance.strip():
                st.error("Application Instance is required.")
            else:
                # Canonical Application Name: "<GroupName> - <Instance>"
                application_name_canonical = f"{selected_group_label} - {application_instance.strip()}"
                app_upper = application_name_canonical.strip().upper()

                # Uniqueness checks (case-insensitive, global)
                group_names = _all_group_names_upper(ver_groups)          # all groups
                app_names = _all_application_names_upper(ver_apps)        # all apps
                if app_upper in app_names:
                    st.error(f"Application name '{application_name_canonical}' already exists.")
                elif app_upper in group_names:
                    st.error(f"Application name '{application_name_canonical}' conflicts with an existing Group name.")
                else:
                    try:
                        upsert_application_instance(
                            application_id=str(uuid.uuid4()),
                            group_id=group_id,
                            application_name=application_name_canonical,  # generated canonical name
                            site=add_info.strip() or None,                # keep param name 'site' for backend; value is Additional Info
                            vendor_id=vendor_id,                           # may be None if group doesn't expose it
                        )
                        bump_version("ver_apps_listing")  # only touch instances table cache
                        st.success(f"Application instance saved as **{application_name_canonical}**.")
                        st.rerun()
                    except Exception as e:
                        st.error(f"Save failed: {e}")

    st.markdown("---")
    st.subheader("Instances for this Team")
    apps = _apps_listing(selected_team_id_i, ver_apps)
    if apps is not None and not apps.empty:
        # Filter to the selected group for a tighter view
        if "GROUPID" in apps.columns:
            apps = apps[apps["GROUPID"] == group_id]
        elif "GROUPNAME" in apps.columns and selected_group_label:
            apps = apps[apps["GROUPNAME"] == selected_group_label]

        # Decide which info column exists (ADD_INFO after DB rename, otherwise SITE)
        info_col = "ADD_INFO" if "ADD_INFO" in apps.columns else ("SITE" if "SITE" in apps.columns else None)

        # Build display columns
        show = ["GROUPNAME", "APPLICATIONNAME"]
        if info_col:
            # Show to the user as "Additional Info"
            apps = apps.rename(columns={info_col: "Additional Info"})
            show.append("Additional Info")

        show = [c for c in show if c in apps.columns]

        if apps.empty:
            st.info("No application instances for this selection.")
        else:
            st.dataframe(apps[show], use_container_width=True, hide_index=True)
    else:
        st.info("No application instances yet for this Team.")

    # ---------- ‚úèÔ∏è Rename an Application Instance ----------
    with st.expander("‚úèÔ∏è Rename an Application Instance"):
        apps_for_group = _apps_listing(selected_team_id_i, ver_apps)
        if apps_for_group is not None and not apps_for_group.empty:
            if "GROUPID" in apps_for_group.columns:
                apps_for_group = apps_for_group[apps_for_group["GROUPID"] == group_id]
            elif "GROUPNAME" in apps_for_group.columns and selected_group_label:
                apps_for_group = apps_for_group[apps_for_group["GROUPNAME"] == selected_group_label]

        if apps_for_group is None or apps_for_group.empty:
            st.info("No application instances available for this Group.")
        else:
            # Select by existing canonical Application Name
            app_name_options = (
                apps_for_group["APPLICATIONNAME"]
                .dropna().astype(str)
                .sort_values().unique().tolist()
            )
            rename_app_name = _select_with_placeholder(
                "Select Application Instance (by name) to rename",
                app_name_options,
                key="inst_rename_select",
            )

            # Decide info col for preserving current Additional Info
            info_col_rg = "ADD_INFO" if "ADD_INFO" in apps_for_group.columns else ("SITE" if "SITE" in apps_for_group.columns else None)

            # Input: new instance label (only the instance part)
            new_instance_label = st.text_input(
                "New Instance Label (will update canonical Application Name)",
                key="inst_rename_new_label",
                disabled=rename_app_name is None
            )

            if st.button("Rename Instance", key="inst_rename_btn", disabled=rename_app_name is None):
                try:
                    app_row = apps_for_group[apps_for_group["APPLICATIONNAME"] == rename_app_name] if rename_app_name else None
                    application_id = _safe_first_value(app_row, "APPLICATIONID") if app_row is not None else None
                    current_info_val = _safe_first_value(app_row, info_col_rg) if (app_row is not None and info_col_rg) else None

                    if not application_id or not new_instance_label.strip():
                        st.error("Please select an instance and enter a new label.")
                    else:
                        # New canonical name = "<GroupName> - <NewInstanceLabel>"
                        new_canonical_name = f"{selected_group_label} - {new_instance_label.strip()}"
                        upsert_application_instance(
                            application_id=str(application_id),
                            group_id=group_id,
                            application_name=new_canonical_name,
                            site=(current_info_val if current_info_val is not None else None),
                            vendor_id=vendor_id,
                        )
                        bump_version("ver_apps_listing")
                        st.success("Instance renamed.")
                        st.rerun()
                except Exception as e:
                    st.error(f"Rename failed: {e}")

    # ---------- Danger zone: delete by Application INSTANCE NAME (not ID) ----------
    with st.expander("Danger zone: Delete an Application Instance"):
        st.caption("‚ö†Ô∏è Deleting an application instance is permanent and cannot be undone.")
        # Build a list of instances for the selected group only
        apps_for_group = _apps_listing(selected_team_id_i, ver_apps)
        if apps_for_group is not None and not apps_for_group.empty:
            if "GROUPID" in apps_for_group.columns:
                apps_for_group = apps_for_group[apps_for_group["GROUPID"] == group_id]
            elif "GROUPNAME" in apps_for_group.columns and selected_group_label:
                apps_for_group = apps_for_group[apps_for_group["GROUPNAME"] == selected_group_label]

        if apps_for_group is None or apps_for_group.empty:
            st.info("No application instances available for this Group.")
        else:
            app_name_options = (
                apps_for_group["APPLICATIONNAME"]
                .dropna().astype(str)
                .sort_values().unique().tolist()
            )
            del_app_name = _select_with_placeholder(
                "Select Application Instance to delete",
                app_name_options,
                key="inst_delete_by_name",
            )
            confirm = st.text_input("Type DELETE to confirm", key="inst_delete_confirm_name", disabled=del_app_name is None)
            st.markdown("**‚ö†Ô∏è This action cannot be undone.**")
            if st.button("üóëÔ∏è Delete Application", key="inst_delete_btn_name", disabled=del_app_name is None):
                if confirm.strip().upper() != "DELETE":
                    st.error("Type DELETE to confirm.")
                else:
                    try:
                        # Map instance name (within this group) -> APPLICATIONID
                        app_row = apps_for_group[apps_for_group["APPLICATIONNAME"] == del_app_name] if del_app_name else None
                        app_id = _safe_first_value(app_row, "APPLICATIONID") if app_row is not None else None
                        if not app_id:
                            st.error("Could not find the selected application instance.")
                        else:
                            delete_application(str(app_id))
                            bump_version("ver_apps_listing")
                            st.success(f"‚úÖ Application instance '{del_app_name}' deleted.")
                            st.rerun()
                    except Exception as e:
                        st.error(f"Delete failed: {e}")
